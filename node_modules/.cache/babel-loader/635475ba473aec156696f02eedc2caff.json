{"ast":null,"code":"import { baseUrl } from '../helpers';\nimport { AppState } from '../utils/types';\nexport default async function getData(dispatch, categories, routes) {\n  const filteredMarkersApi = `${baseUrl}/markers/${categories}`;\n  const filteredRoutesApi = `${baseUrl}/routes/${routes}`;\n  const getMarkers = fetch(filteredMarkersApi).then(blob => blob.json()).then(data => {\n    // Add data to markers array.\n    const markerData = Object.values(data); // Get marker data\n\n    const mapMarkers = markerData.map(marker => {\n      var _marker$categories;\n\n      const markerCategories = (_marker$categories = marker.categories) === null || _marker$categories === void 0 ? void 0 : _marker$categories.map(category => {\n        return category.tid;\n      });\n      return {\n        lat: marker.lat,\n        lng: marker.lng,\n        position: [parseFloat(marker === null || marker === void 0 ? void 0 : marker.lat), parseFloat(marker.lng)],\n        summary: marker.summary,\n        content: marker.content,\n        distance: marker.distance,\n        postcode: marker.postcode,\n        accessibility_terrain_walk_info: marker.accessibility_terrain_walk_info,\n        facilities_accessibility: marker.facilities_accessibility,\n        id: marker.id,\n        title: marker.title,\n        image: marker.image,\n        imageAlt: marker.imageAlt,\n        categories: markerCategories,\n        links: marker.links,\n        download: marker.download\n      };\n    }); // Get taxo data\n    // Get user provided term IDs and convert to array of tid ints\n\n    const chosenCategories = categories.split(',').map(tid => +tid);\n    const mapCategoryParents = markerData.map(marker => {\n      return marker.categories.filter(term => term.parent === 0);\n    }).flat() // Remove duplicates\n    .filter((termToCheck, i, terms) => terms.findIndex(term => term.tid === termToCheck.tid) === i) // Only add user chosen categories to array\n    .filter(parentCat => chosenCategories.includes(parentCat.tid)); // Combine parent & child categories to form filters, removing any that aren't in the list provided by the user\n\n    const categoryData = mapCategoryParents // Find child terms & add to parent term object\n    .map(category => {\n      const childTerms = markerData.map(marker => {\n        return marker.categories.filter(term => term.parent !== 0);\n      }).flat() // Remove duplicates\n      .filter((termToCheck, i, terms) => terms.findIndex(term => term.tid === termToCheck.tid) === i) // Filter to children of the parent term\n      .filter(childTerm => category.tid === childTerm.parent);\n      return { ...category,\n        children: childTerms\n      };\n    });\n    dispatch({\n      type: AppState.SET_DATA,\n      mode: mapMarkers\n    });\n    dispatch({\n      type: AppState.SET_CATEGORIES,\n      mode: categoryData\n    });\n  }).catch(err => {\n    dispatch({\n      type: AppState.ERROR,\n      mode: true\n    });\n    throw Error(err);\n  });\n  let getRoutes;\n\n  if (routes) {\n    getRoutes = fetch(filteredRoutesApi).then(blob => blob.json()).then(data => {\n      // Add data to routes array.\n      const routeData = Object.values(data); // Get route data\n\n      const mapRoutes = routeData.map(route => {\n        var _route$categories;\n\n        const routeCategories = (_route$categories = route.categories) === null || _route$categories === void 0 ? void 0 : _route$categories.map(category => {\n          return category.tid;\n        });\n        return {\n          shape_file: route.shape_file,\n          summary: route.summary,\n          content: route.content,\n          distance: route.distance,\n          postcode: route.postcode,\n          accessibility_terrain_walk_info: route.accessibility_terrain_walk_info,\n          facilities_accessibility: route.facilities_accessibility,\n          id: route.id,\n          title: route.title,\n          image: route.image,\n          imageAlt: route.imageAlt,\n          categories: routeCategories,\n          links: route.links,\n          download: route.download\n        };\n      }); // Get taxo data\n\n      const chosenCategories = routes.split(',').map(tid => +tid);\n      const categoryData = routeData.map(route => {\n        return route.categories.filter(term => term.parent === 0);\n      }).flat() // Remove duplicates\n      .filter((termToCheck, i, terms) => terms.findIndex(term => term.tid === termToCheck.tid) === i) // Only add user chosen categories to array\n      .filter(parentCat => chosenCategories.includes(parentCat.tid));\n      dispatch({\n        type: AppState.SET_ROUTES,\n        mode: mapRoutes\n      });\n      dispatch({\n        type: AppState.SET_ROUTE_CATEGORIES,\n        mode: categoryData\n      });\n    }).catch(err => {\n      dispatch({\n        type: AppState.ERROR,\n        mode: true\n      });\n      throw Error(err);\n    });\n  }\n\n  await Promise.all([await getMarkers, routes ? await getRoutes : null]).then(() => {\n    dispatch({\n      type: AppState.IS_LOADING,\n      mode: false\n    });\n  }).catch(err => {\n    dispatch({\n      type: AppState.ERROR,\n      mode: true\n    });\n    throw Error(err);\n  });\n}","map":{"version":3,"names":["baseUrl","AppState","getData","dispatch","categories","routes","filteredMarkersApi","filteredRoutesApi","getMarkers","fetch","then","blob","json","data","markerData","Object","values","mapMarkers","map","marker","markerCategories","category","tid","lat","lng","position","parseFloat","summary","content","distance","postcode","accessibility_terrain_walk_info","facilities_accessibility","id","title","image","imageAlt","links","download","chosenCategories","split","mapCategoryParents","filter","term","parent","flat","termToCheck","i","terms","findIndex","parentCat","includes","categoryData","childTerms","childTerm","children","type","SET_DATA","mode","SET_CATEGORIES","catch","err","ERROR","Error","getRoutes","routeData","mapRoutes","route","routeCategories","shape_file","SET_ROUTES","SET_ROUTE_CATEGORIES","Promise","all","IS_LOADING"],"sources":["/Users/harryedwards/Work/FL/_examples/mapping/src/data/getData.ts"],"sourcesContent":["import { baseUrl } from '../helpers'\nimport { AppState, StateAction } from '../utils/types'\nimport { LinkEntity, TaxonomyEntity } from '../utils/types'\n\n// type Props = {\n//   categories: string\n// }\n\ninterface MapEntityRaw {\n  summary?: string | null\n  content?: string | null\n  distance?: string | null\n  postcode?: string | null\n  accessibility_terrain_walk_info?: string | null\n  facilities_accessibility?: string | null\n  id?: number | null\n  title?: string | null\n  image?: boolean | null\n  imageAlt?: boolean | null\n  categories?: TaxonomyEntity[] | null\n  links?: LinkEntity[] | null\n  download?: string | null\n}\n\ninterface MarkerRaw extends MapEntityRaw {\n  lat?: string | null\n  lng?: string | null\n}\ninterface RouteRaw extends MapEntityRaw {\n  shape_file: string\n}\n\nexport default async function getData(\n  dispatch: React.Dispatch<StateAction>,\n  categories: string,\n  routes: string\n) {\n  const filteredMarkersApi = `${baseUrl}/markers/${categories}`\n  const filteredRoutesApi = `${baseUrl}/routes/${routes}`\n\n  const getMarkers = fetch(filteredMarkersApi)\n    .then(blob => blob.json())\n    .then(data => {\n      // Add data to markers array.\n      const markerData = Object.values(data)\n\n      // Get marker data\n      const mapMarkers = markerData.map((marker: any) => {\n        const markerCategories = marker.categories?.map((category: any) => {\n          return category.tid\n        })\n\n        return {\n          lat: marker.lat,\n          lng: marker.lng,\n          position: [parseFloat(marker?.lat), parseFloat(marker.lng)],\n          summary: marker.summary,\n          content: marker.content,\n          distance: marker.distance,\n          postcode: marker.postcode,\n          accessibility_terrain_walk_info:\n            marker.accessibility_terrain_walk_info,\n          facilities_accessibility: marker.facilities_accessibility,\n          id: marker.id,\n          title: marker.title,\n          image: marker.image,\n          imageAlt: marker.imageAlt,\n          categories: markerCategories,\n          links: marker.links,\n          download: marker.download,\n        }\n      })\n\n      // Get taxo data\n      // Get user provided term IDs and convert to array of tid ints\n      const chosenCategories = categories.split(',').map(tid => +tid)\n\n      const mapCategoryParents = markerData\n        .map((marker: any) => {\n          return marker.categories.filter((term: any) => term.parent === 0)\n        })\n        .flat()\n        // Remove duplicates\n        .filter(\n          (termToCheck: TaxonomyEntity, i: number, terms: TaxonomyEntity[]) =>\n            terms.findIndex(\n              (term: TaxonomyEntity) => term.tid === termToCheck.tid\n            ) === i\n        )\n        // Only add user chosen categories to array\n        .filter((parentCat: TaxonomyEntity) =>\n          chosenCategories.includes(parentCat.tid)\n        )\n\n      // Combine parent & child categories to form filters, removing any that aren't in the list provided by the user\n      const categoryData = mapCategoryParents\n        // Find child terms & add to parent term object\n        .map((category: TaxonomyEntity) => {\n          const childTerms = markerData\n            .map((marker: any) => {\n              return marker.categories.filter(\n                (term: TaxonomyEntity) => term.parent !== 0\n              )\n            })\n            .flat()\n            // Remove duplicates\n            .filter(\n              (\n                termToCheck: TaxonomyEntity,\n                i: number,\n                terms: TaxonomyEntity[]\n              ) =>\n                terms.findIndex(\n                  (term: TaxonomyEntity) => term.tid === termToCheck.tid\n                ) === i\n            )\n            // Filter to children of the parent term\n            .filter(\n              (childTerm: TaxonomyEntity) => category.tid === childTerm.parent\n            )\n\n          return {\n            ...category,\n            children: childTerms,\n          }\n        })\n\n      dispatch({ type: AppState.SET_DATA, mode: mapMarkers })\n      dispatch({ type: AppState.SET_CATEGORIES, mode: categoryData })\n    })\n    .catch(err => {\n      dispatch({ type: AppState.ERROR, mode: true })\n      throw Error(err)\n    })\n\n  let getRoutes\n\n  if (routes) {\n    getRoutes = fetch(filteredRoutesApi)\n      .then(blob => blob.json())\n      .then(data => {\n        // Add data to routes array.\n        const routeData = Object.values(data)\n\n        // Get route data\n        const mapRoutes = routeData.map((route: any) => {\n          const routeCategories = route.categories?.map((category: any) => {\n            return category.tid\n          })\n\n          return {\n            shape_file: route.shape_file,\n            summary: route.summary,\n            content: route.content,\n            distance: route.distance,\n            postcode: route.postcode,\n            accessibility_terrain_walk_info:\n              route.accessibility_terrain_walk_info,\n            facilities_accessibility: route.facilities_accessibility,\n            id: route.id,\n            title: route.title,\n            image: route.image,\n            imageAlt: route.imageAlt,\n            categories: routeCategories,\n            links: route.links,\n            download: route.download,\n          }\n        })\n\n        // Get taxo data\n        const chosenCategories = routes.split(',').map(tid => +tid)\n\n        const categoryData = routeData\n          .map((route: MarkerRaw) => {\n            return route.categories.filter(term => term.parent === 0)\n          })\n          .flat()\n          // Remove duplicates\n          .filter(\n            (termToCheck: TaxonomyEntity, i: number, terms: TaxonomyEntity[]) =>\n              terms.findIndex(\n                (term: TaxonomyEntity) => term.tid === termToCheck.tid\n              ) === i\n          )\n          // Only add user chosen categories to array\n          .filter((parentCat: TaxonomyEntity) =>\n            chosenCategories.includes(parentCat.tid)\n          )\n\n        dispatch({ type: AppState.SET_ROUTES, mode: mapRoutes })\n        dispatch({ type: AppState.SET_ROUTE_CATEGORIES, mode: categoryData })\n      })\n      .catch(err => {\n        dispatch({ type: AppState.ERROR, mode: true })\n        throw Error(err)\n      })\n  }\n\n  await Promise.all([await getMarkers, routes ? await getRoutes : null])\n    .then(() => {\n      dispatch({ type: AppState.IS_LOADING, mode: false })\n    })\n    .catch(err => {\n      dispatch({ type: AppState.ERROR, mode: true })\n      throw Error(err)\n    })\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}